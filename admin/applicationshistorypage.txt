"use client"

import { useState, useMemo } from "react"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { StatusBadge } from "@/components/status-badge"
import { FileText } from "lucide-react"
import { formatDistanceToNow } from "date-fns"
import { DataTable } from "@/components/ui/data-table"
import type { ColumnDef } from "@tanstack/react-table"

interface HistoricalApplication {
  id: string
  organizationName: string
  businessName: string
  applicationType: "new_business" | "additional_accounts"
  accountsRequested: number
  status: "completed" | "rejected" | "cancelled"
  submittedAt: string
  completedAt?: string
  rejectedAt?: string
  assignedBmId?: string
  assignedAdAccountIds?: string[]
  rejectionReason?: string
}

// Generate mock historical data
const generateMockHistory = (count: number): HistoricalApplication[] => {
  const applications: HistoricalApplication[] = []
  const statuses: HistoricalApplication["status"][] = ["completed", "rejected", "cancelled"]
  const types: HistoricalApplication["applicationType"][] = ["new_business", "additional_accounts"]

  for (let i = 1; i <= count; i++) {
    const status = statuses[Math.floor(Math.random() * statuses.length)]
    const submittedDate = new Date(Date.now() - Math.random() * 90 * 24 * 60 * 60 * 1000)
    const completedDate = new Date(submittedDate.getTime() + Math.random() * 7 * 24 * 60 * 60 * 1000)

    applications.push({
      id: `app-${i.toString().padStart(3, "0")}`,
      organizationName: `Organization ${i}`,
      businessName: `Business ${i}`,
      applicationType: types[Math.floor(Math.random() * types.length)],
      accountsRequested: Math.floor(Math.random() * 5) + 1,
      status,
      submittedAt: submittedDate.toISOString(),
      completedAt: status === "completed" ? completedDate.toISOString() : undefined,
      rejectedAt: status === "rejected" ? completedDate.toISOString() : undefined,
      assignedBmId: status === "completed" ? `bm_${Math.floor(Math.random() * 1000000)}` : undefined,
      assignedAdAccountIds: status === "completed" ? [`act_${Math.floor(Math.random() * 1000)}`] : undefined,
      rejectionReason: status === "rejected" ? "Policy violation" : undefined,
    })
  }
  return applications.sort((a, b) => new Date(b.submittedAt).getTime() - new Date(a.submittedAt).getTime())
}

export default function ApplicationHistoryPage() {
  const [applications] = useState(() => generateMockHistory(800))
  const [statusFilter, setStatusFilter] = useState("all")

  const filteredApplications = useMemo(() => {
    return applications.filter((app) => {
      const matchesStatus = statusFilter === "all" || app.status === statusFilter
      return matchesStatus
    })
  }, [applications, statusFilter])

  const columns: ColumnDef<HistoricalApplication>[] = [
    {
      accessorKey: "organizationName",
      header: "Application",
      size: 200,
      cell: ({ row }) => {
        const app = row.original
        return (
          <div className="min-w-0">
            <div className="font-medium text-sm truncate">{app.businessName}</div>
            <div className="text-xs text-muted-foreground truncate">{app.organizationName}</div>
          </div>
        )
      },
    },
    {
      accessorKey: "applicationType",
      header: "Type",
      size: 120,
      cell: ({ row }) => (
        <Badge variant={row.original.applicationType === "new_business" ? "default" : "secondary"} className="text-xs">
          {row.original.applicationType === "new_business" ? "New" : "Additional"}
        </Badge>
      ),
    },
    {
      accessorKey: "accountsRequested",
      header: "Accounts",
      size: 80,
      cell: ({ row }) => <div className="text-sm">{row.original.accountsRequested}</div>,
    },
    {
      accessorKey: "status",
      header: "Status",
      size: 100,
      cell: ({ row }) => <StatusBadge status={row.original.status === "completed" ? "active" : "failed"} size="sm" />,
    },
    {
      accessorKey: "submittedAt",
      header: "Submitted",
      size: 100,
      cell: ({ row }) => (
        <div className="text-xs">{formatDistanceToNow(new Date(row.original.submittedAt), { addSuffix: true })}</div>
      ),
    },
    {
      accessorKey: "completedAt",
      header: "Completed",
      size: 100,
      cell: ({ row }) => (
        <div className="text-xs">
          {row.original.completedAt && formatDistanceToNow(new Date(row.original.completedAt), { addSuffix: true })}
        </div>
      ),
    },
    {
      accessorKey: "assignedBmId",
      header: "Assignment",
      size: 120,
      cell: ({ row }) => {
        const app = row.original
        return app.assignedBmId ? (
          <div className="text-xs">
            <div>BM: {app.assignedBmId}</div>
            <div>{app.assignedAdAccountIds?.length} accounts</div>
          </div>
        ) : (
          <span className="text-xs text-muted-foreground">None</span>
        )
      },
    },
  ]

  return (
    <div className="h-full flex flex-col overflow-hidden">
      <div className="flex-shrink-0 p-4 pb-0">
        <div className="flex items-center justify-between">
          <div className="text-sm text-muted-foreground">{applications.length} applications total</div>
          <Button variant="outline" size="sm">
            <FileText className="h-4 w-4 mr-2" />
            Export CSV
          </Button>
        </div>
      </div>

      <div className="flex-1 min-h-0 px-6 pb-6">
        <DataTable
          columns={columns}
          data={filteredApplications}
          searchKey="organizationName"
          searchPlaceholder="Search applications..."
        />
      </div>
    </div>
  )
}
