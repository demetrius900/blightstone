revoke delete on table "public"."application" from "anon";

revoke insert on table "public"."application" from "anon";

revoke references on table "public"."application" from "anon";

revoke select on table "public"."application" from "anon";

revoke trigger on table "public"."application" from "anon";

revoke truncate on table "public"."application" from "anon";

revoke update on table "public"."application" from "anon";

revoke delete on table "public"."application" from "authenticated";

revoke insert on table "public"."application" from "authenticated";

revoke references on table "public"."application" from "authenticated";

revoke select on table "public"."application" from "authenticated";

revoke trigger on table "public"."application" from "authenticated";

revoke truncate on table "public"."application" from "authenticated";

revoke update on table "public"."application" from "authenticated";

revoke delete on table "public"."application" from "service_role";

revoke insert on table "public"."application" from "service_role";

revoke references on table "public"."application" from "service_role";

revoke select on table "public"."application" from "service_role";

revoke trigger on table "public"."application" from "service_role";

revoke truncate on table "public"."application" from "service_role";

revoke update on table "public"."application" from "service_role";

revoke delete on table "public"."application_fulfillment" from "anon";

revoke insert on table "public"."application_fulfillment" from "anon";

revoke references on table "public"."application_fulfillment" from "anon";

revoke select on table "public"."application_fulfillment" from "anon";

revoke trigger on table "public"."application_fulfillment" from "anon";

revoke truncate on table "public"."application_fulfillment" from "anon";

revoke update on table "public"."application_fulfillment" from "anon";

revoke delete on table "public"."application_fulfillment" from "authenticated";

revoke insert on table "public"."application_fulfillment" from "authenticated";

revoke references on table "public"."application_fulfillment" from "authenticated";

revoke select on table "public"."application_fulfillment" from "authenticated";

revoke trigger on table "public"."application_fulfillment" from "authenticated";

revoke truncate on table "public"."application_fulfillment" from "authenticated";

revoke update on table "public"."application_fulfillment" from "authenticated";

revoke delete on table "public"."application_fulfillment" from "service_role";

revoke insert on table "public"."application_fulfillment" from "service_role";

revoke references on table "public"."application_fulfillment" from "service_role";

revoke select on table "public"."application_fulfillment" from "service_role";

revoke trigger on table "public"."application_fulfillment" from "service_role";

revoke truncate on table "public"."application_fulfillment" from "service_role";

revoke update on table "public"."application_fulfillment" from "service_role";

revoke delete on table "public"."asset" from "anon";

revoke insert on table "public"."asset" from "anon";

revoke references on table "public"."asset" from "anon";

revoke select on table "public"."asset" from "anon";

revoke trigger on table "public"."asset" from "anon";

revoke truncate on table "public"."asset" from "anon";

revoke update on table "public"."asset" from "anon";

revoke delete on table "public"."asset" from "authenticated";

revoke insert on table "public"."asset" from "authenticated";

revoke references on table "public"."asset" from "authenticated";

revoke select on table "public"."asset" from "authenticated";

revoke trigger on table "public"."asset" from "authenticated";

revoke truncate on table "public"."asset" from "authenticated";

revoke update on table "public"."asset" from "authenticated";

revoke delete on table "public"."asset" from "service_role";

revoke insert on table "public"."asset" from "service_role";

revoke references on table "public"."asset" from "service_role";

revoke select on table "public"."asset" from "service_role";

revoke trigger on table "public"."asset" from "service_role";

revoke truncate on table "public"."asset" from "service_role";

revoke update on table "public"."asset" from "service_role";

revoke delete on table "public"."asset_binding" from "anon";

revoke insert on table "public"."asset_binding" from "anon";

revoke references on table "public"."asset_binding" from "anon";

revoke select on table "public"."asset_binding" from "anon";

revoke trigger on table "public"."asset_binding" from "anon";

revoke truncate on table "public"."asset_binding" from "anon";

revoke update on table "public"."asset_binding" from "anon";

revoke delete on table "public"."asset_binding" from "authenticated";

revoke insert on table "public"."asset_binding" from "authenticated";

revoke references on table "public"."asset_binding" from "authenticated";

revoke select on table "public"."asset_binding" from "authenticated";

revoke trigger on table "public"."asset_binding" from "authenticated";

revoke truncate on table "public"."asset_binding" from "authenticated";

revoke update on table "public"."asset_binding" from "authenticated";

revoke delete on table "public"."asset_binding" from "service_role";

revoke insert on table "public"."asset_binding" from "service_role";

revoke references on table "public"."asset_binding" from "service_role";

revoke select on table "public"."asset_binding" from "service_role";

revoke trigger on table "public"."asset_binding" from "service_role";

revoke truncate on table "public"."asset_binding" from "service_role";

revoke update on table "public"."asset_binding" from "service_role";

revoke delete on table "public"."bank_transfer_requests" from "anon";

revoke insert on table "public"."bank_transfer_requests" from "anon";

revoke references on table "public"."bank_transfer_requests" from "anon";

revoke select on table "public"."bank_transfer_requests" from "anon";

revoke trigger on table "public"."bank_transfer_requests" from "anon";

revoke truncate on table "public"."bank_transfer_requests" from "anon";

revoke update on table "public"."bank_transfer_requests" from "anon";

revoke delete on table "public"."bank_transfer_requests" from "authenticated";

revoke insert on table "public"."bank_transfer_requests" from "authenticated";

revoke references on table "public"."bank_transfer_requests" from "authenticated";

revoke select on table "public"."bank_transfer_requests" from "authenticated";

revoke trigger on table "public"."bank_transfer_requests" from "authenticated";

revoke truncate on table "public"."bank_transfer_requests" from "authenticated";

revoke update on table "public"."bank_transfer_requests" from "authenticated";

revoke delete on table "public"."bank_transfer_requests" from "service_role";

revoke insert on table "public"."bank_transfer_requests" from "service_role";

revoke references on table "public"."bank_transfer_requests" from "service_role";

revoke select on table "public"."bank_transfer_requests" from "service_role";

revoke trigger on table "public"."bank_transfer_requests" from "service_role";

revoke truncate on table "public"."bank_transfer_requests" from "service_role";

revoke update on table "public"."bank_transfer_requests" from "service_role";

revoke delete on table "public"."binance_pay_orders" from "anon";

revoke insert on table "public"."binance_pay_orders" from "anon";

revoke references on table "public"."binance_pay_orders" from "anon";

revoke select on table "public"."binance_pay_orders" from "anon";

revoke trigger on table "public"."binance_pay_orders" from "anon";

revoke truncate on table "public"."binance_pay_orders" from "anon";

revoke update on table "public"."binance_pay_orders" from "anon";

revoke delete on table "public"."binance_pay_orders" from "authenticated";

revoke insert on table "public"."binance_pay_orders" from "authenticated";

revoke references on table "public"."binance_pay_orders" from "authenticated";

revoke select on table "public"."binance_pay_orders" from "authenticated";

revoke trigger on table "public"."binance_pay_orders" from "authenticated";

revoke truncate on table "public"."binance_pay_orders" from "authenticated";

revoke update on table "public"."binance_pay_orders" from "authenticated";

revoke delete on table "public"."binance_pay_orders" from "service_role";

revoke insert on table "public"."binance_pay_orders" from "service_role";

revoke references on table "public"."binance_pay_orders" from "service_role";

revoke select on table "public"."binance_pay_orders" from "service_role";

revoke trigger on table "public"."binance_pay_orders" from "service_role";

revoke truncate on table "public"."binance_pay_orders" from "service_role";

revoke update on table "public"."binance_pay_orders" from "service_role";

revoke delete on table "public"."bm_domains" from "anon";

revoke insert on table "public"."bm_domains" from "anon";

revoke references on table "public"."bm_domains" from "anon";

revoke select on table "public"."bm_domains" from "anon";

revoke trigger on table "public"."bm_domains" from "anon";

revoke truncate on table "public"."bm_domains" from "anon";

revoke update on table "public"."bm_domains" from "anon";

revoke delete on table "public"."bm_domains" from "authenticated";

revoke insert on table "public"."bm_domains" from "authenticated";

revoke references on table "public"."bm_domains" from "authenticated";

revoke select on table "public"."bm_domains" from "authenticated";

revoke trigger on table "public"."bm_domains" from "authenticated";

revoke truncate on table "public"."bm_domains" from "authenticated";

revoke update on table "public"."bm_domains" from "authenticated";

revoke delete on table "public"."bm_domains" from "service_role";

revoke insert on table "public"."bm_domains" from "service_role";

revoke references on table "public"."bm_domains" from "service_role";

revoke select on table "public"."bm_domains" from "service_role";

revoke trigger on table "public"."bm_domains" from "service_role";

revoke truncate on table "public"."bm_domains" from "service_role";

revoke update on table "public"."bm_domains" from "service_role";

revoke delete on table "public"."onboarding_states" from "anon";

revoke insert on table "public"."onboarding_states" from "anon";

revoke references on table "public"."onboarding_states" from "anon";

revoke select on table "public"."onboarding_states" from "anon";

revoke trigger on table "public"."onboarding_states" from "anon";

revoke truncate on table "public"."onboarding_states" from "anon";

revoke update on table "public"."onboarding_states" from "anon";

revoke delete on table "public"."onboarding_states" from "authenticated";

revoke insert on table "public"."onboarding_states" from "authenticated";

revoke references on table "public"."onboarding_states" from "authenticated";

revoke select on table "public"."onboarding_states" from "authenticated";

revoke trigger on table "public"."onboarding_states" from "authenticated";

revoke truncate on table "public"."onboarding_states" from "authenticated";

revoke update on table "public"."onboarding_states" from "authenticated";

revoke delete on table "public"."onboarding_states" from "service_role";

revoke insert on table "public"."onboarding_states" from "service_role";

revoke references on table "public"."onboarding_states" from "service_role";

revoke select on table "public"."onboarding_states" from "service_role";

revoke trigger on table "public"."onboarding_states" from "service_role";

revoke truncate on table "public"."onboarding_states" from "service_role";

revoke update on table "public"."onboarding_states" from "service_role";

revoke delete on table "public"."organization_members" from "anon";

revoke insert on table "public"."organization_members" from "anon";

revoke references on table "public"."organization_members" from "anon";

revoke select on table "public"."organization_members" from "anon";

revoke trigger on table "public"."organization_members" from "anon";

revoke truncate on table "public"."organization_members" from "anon";

revoke update on table "public"."organization_members" from "anon";

revoke delete on table "public"."organization_members" from "authenticated";

revoke insert on table "public"."organization_members" from "authenticated";

revoke references on table "public"."organization_members" from "authenticated";

revoke select on table "public"."organization_members" from "authenticated";

revoke trigger on table "public"."organization_members" from "authenticated";

revoke truncate on table "public"."organization_members" from "authenticated";

revoke update on table "public"."organization_members" from "authenticated";

revoke delete on table "public"."organization_members" from "service_role";

revoke insert on table "public"."organization_members" from "service_role";

revoke references on table "public"."organization_members" from "service_role";

revoke select on table "public"."organization_members" from "service_role";

revoke trigger on table "public"."organization_members" from "service_role";

revoke truncate on table "public"."organization_members" from "service_role";

revoke update on table "public"."organization_members" from "service_role";

revoke delete on table "public"."organizations" from "anon";

revoke insert on table "public"."organizations" from "anon";

revoke references on table "public"."organizations" from "anon";

revoke select on table "public"."organizations" from "anon";

revoke trigger on table "public"."organizations" from "anon";

revoke truncate on table "public"."organizations" from "anon";

revoke update on table "public"."organizations" from "anon";

revoke delete on table "public"."organizations" from "authenticated";

revoke insert on table "public"."organizations" from "authenticated";

revoke references on table "public"."organizations" from "authenticated";

revoke select on table "public"."organizations" from "authenticated";

revoke trigger on table "public"."organizations" from "authenticated";

revoke truncate on table "public"."organizations" from "authenticated";

revoke update on table "public"."organizations" from "authenticated";

revoke delete on table "public"."organizations" from "service_role";

revoke insert on table "public"."organizations" from "service_role";

revoke references on table "public"."organizations" from "service_role";

revoke select on table "public"."organizations" from "service_role";

revoke trigger on table "public"."organizations" from "service_role";

revoke truncate on table "public"."organizations" from "service_role";

revoke update on table "public"."organizations" from "service_role";

revoke delete on table "public"."plans" from "anon";

revoke insert on table "public"."plans" from "anon";

revoke references on table "public"."plans" from "anon";

revoke select on table "public"."plans" from "anon";

revoke trigger on table "public"."plans" from "anon";

revoke truncate on table "public"."plans" from "anon";

revoke update on table "public"."plans" from "anon";

revoke delete on table "public"."plans" from "authenticated";

revoke insert on table "public"."plans" from "authenticated";

revoke references on table "public"."plans" from "authenticated";

revoke select on table "public"."plans" from "authenticated";

revoke trigger on table "public"."plans" from "authenticated";

revoke truncate on table "public"."plans" from "authenticated";

revoke update on table "public"."plans" from "authenticated";

revoke delete on table "public"."plans" from "service_role";

revoke insert on table "public"."plans" from "service_role";

revoke references on table "public"."plans" from "service_role";

revoke select on table "public"."plans" from "service_role";

revoke trigger on table "public"."plans" from "service_role";

revoke truncate on table "public"."plans" from "service_role";

revoke update on table "public"."plans" from "service_role";

revoke delete on table "public"."profiles" from "anon";

revoke insert on table "public"."profiles" from "anon";

revoke references on table "public"."profiles" from "anon";

revoke select on table "public"."profiles" from "anon";

revoke trigger on table "public"."profiles" from "anon";

revoke truncate on table "public"."profiles" from "anon";

revoke update on table "public"."profiles" from "anon";

revoke delete on table "public"."profiles" from "authenticated";

revoke insert on table "public"."profiles" from "authenticated";

revoke references on table "public"."profiles" from "authenticated";

revoke select on table "public"."profiles" from "authenticated";

revoke trigger on table "public"."profiles" from "authenticated";

revoke truncate on table "public"."profiles" from "authenticated";

revoke update on table "public"."profiles" from "authenticated";

revoke delete on table "public"."profiles" from "service_role";

revoke insert on table "public"."profiles" from "service_role";

revoke references on table "public"."profiles" from "service_role";

revoke select on table "public"."profiles" from "service_role";

revoke trigger on table "public"."profiles" from "service_role";

revoke truncate on table "public"."profiles" from "service_role";

revoke update on table "public"."profiles" from "service_role";

revoke delete on table "public"."promotion_urls" from "anon";

revoke insert on table "public"."promotion_urls" from "anon";

revoke references on table "public"."promotion_urls" from "anon";

revoke select on table "public"."promotion_urls" from "anon";

revoke trigger on table "public"."promotion_urls" from "anon";

revoke truncate on table "public"."promotion_urls" from "anon";

revoke update on table "public"."promotion_urls" from "anon";

revoke delete on table "public"."promotion_urls" from "authenticated";

revoke insert on table "public"."promotion_urls" from "authenticated";

revoke references on table "public"."promotion_urls" from "authenticated";

revoke select on table "public"."promotion_urls" from "authenticated";

revoke trigger on table "public"."promotion_urls" from "authenticated";

revoke truncate on table "public"."promotion_urls" from "authenticated";

revoke update on table "public"."promotion_urls" from "authenticated";

revoke delete on table "public"."promotion_urls" from "service_role";

revoke insert on table "public"."promotion_urls" from "service_role";

revoke references on table "public"."promotion_urls" from "service_role";

revoke select on table "public"."promotion_urls" from "service_role";

revoke trigger on table "public"."promotion_urls" from "service_role";

revoke truncate on table "public"."promotion_urls" from "service_role";

revoke update on table "public"."promotion_urls" from "service_role";

revoke delete on table "public"."subscriptions" from "anon";

revoke insert on table "public"."subscriptions" from "anon";

revoke references on table "public"."subscriptions" from "anon";

revoke select on table "public"."subscriptions" from "anon";

revoke trigger on table "public"."subscriptions" from "anon";

revoke truncate on table "public"."subscriptions" from "anon";

revoke update on table "public"."subscriptions" from "anon";

revoke delete on table "public"."subscriptions" from "authenticated";

revoke insert on table "public"."subscriptions" from "authenticated";

revoke references on table "public"."subscriptions" from "authenticated";

revoke select on table "public"."subscriptions" from "authenticated";

revoke trigger on table "public"."subscriptions" from "authenticated";

revoke truncate on table "public"."subscriptions" from "authenticated";

revoke update on table "public"."subscriptions" from "authenticated";

revoke delete on table "public"."subscriptions" from "service_role";

revoke insert on table "public"."subscriptions" from "service_role";

revoke references on table "public"."subscriptions" from "service_role";

revoke select on table "public"."subscriptions" from "service_role";

revoke trigger on table "public"."subscriptions" from "service_role";

revoke truncate on table "public"."subscriptions" from "service_role";

revoke update on table "public"."subscriptions" from "service_role";

revoke delete on table "public"."support_ticket_attachments" from "anon";

revoke insert on table "public"."support_ticket_attachments" from "anon";

revoke references on table "public"."support_ticket_attachments" from "anon";

revoke select on table "public"."support_ticket_attachments" from "anon";

revoke trigger on table "public"."support_ticket_attachments" from "anon";

revoke truncate on table "public"."support_ticket_attachments" from "anon";

revoke update on table "public"."support_ticket_attachments" from "anon";

revoke delete on table "public"."support_ticket_attachments" from "authenticated";

revoke insert on table "public"."support_ticket_attachments" from "authenticated";

revoke references on table "public"."support_ticket_attachments" from "authenticated";

revoke select on table "public"."support_ticket_attachments" from "authenticated";

revoke trigger on table "public"."support_ticket_attachments" from "authenticated";

revoke truncate on table "public"."support_ticket_attachments" from "authenticated";

revoke update on table "public"."support_ticket_attachments" from "authenticated";

revoke delete on table "public"."support_ticket_attachments" from "service_role";

revoke insert on table "public"."support_ticket_attachments" from "service_role";

revoke references on table "public"."support_ticket_attachments" from "service_role";

revoke select on table "public"."support_ticket_attachments" from "service_role";

revoke trigger on table "public"."support_ticket_attachments" from "service_role";

revoke truncate on table "public"."support_ticket_attachments" from "service_role";

revoke update on table "public"."support_ticket_attachments" from "service_role";

revoke delete on table "public"."support_ticket_messages" from "anon";

revoke insert on table "public"."support_ticket_messages" from "anon";

revoke references on table "public"."support_ticket_messages" from "anon";

revoke select on table "public"."support_ticket_messages" from "anon";

revoke trigger on table "public"."support_ticket_messages" from "anon";

revoke truncate on table "public"."support_ticket_messages" from "anon";

revoke update on table "public"."support_ticket_messages" from "anon";

revoke delete on table "public"."support_ticket_messages" from "authenticated";

revoke insert on table "public"."support_ticket_messages" from "authenticated";

revoke references on table "public"."support_ticket_messages" from "authenticated";

revoke select on table "public"."support_ticket_messages" from "authenticated";

revoke trigger on table "public"."support_ticket_messages" from "authenticated";

revoke truncate on table "public"."support_ticket_messages" from "authenticated";

revoke update on table "public"."support_ticket_messages" from "authenticated";

revoke delete on table "public"."support_ticket_messages" from "service_role";

revoke insert on table "public"."support_ticket_messages" from "service_role";

revoke references on table "public"."support_ticket_messages" from "service_role";

revoke select on table "public"."support_ticket_messages" from "service_role";

revoke trigger on table "public"."support_ticket_messages" from "service_role";

revoke truncate on table "public"."support_ticket_messages" from "service_role";

revoke update on table "public"."support_ticket_messages" from "service_role";

revoke delete on table "public"."support_tickets" from "anon";

revoke insert on table "public"."support_tickets" from "anon";

revoke references on table "public"."support_tickets" from "anon";

revoke select on table "public"."support_tickets" from "anon";

revoke trigger on table "public"."support_tickets" from "anon";

revoke truncate on table "public"."support_tickets" from "anon";

revoke update on table "public"."support_tickets" from "anon";

revoke delete on table "public"."support_tickets" from "authenticated";

revoke insert on table "public"."support_tickets" from "authenticated";

revoke references on table "public"."support_tickets" from "authenticated";

revoke select on table "public"."support_tickets" from "authenticated";

revoke trigger on table "public"."support_tickets" from "authenticated";

revoke truncate on table "public"."support_tickets" from "authenticated";

revoke update on table "public"."support_tickets" from "authenticated";

revoke delete on table "public"."support_tickets" from "service_role";

revoke insert on table "public"."support_tickets" from "service_role";

revoke references on table "public"."support_tickets" from "service_role";

revoke select on table "public"."support_tickets" from "service_role";

revoke trigger on table "public"."support_tickets" from "service_role";

revoke truncate on table "public"."support_tickets" from "service_role";

revoke update on table "public"."support_tickets" from "service_role";

revoke delete on table "public"."topup_requests" from "anon";

revoke insert on table "public"."topup_requests" from "anon";

revoke references on table "public"."topup_requests" from "anon";

revoke select on table "public"."topup_requests" from "anon";

revoke trigger on table "public"."topup_requests" from "anon";

revoke truncate on table "public"."topup_requests" from "anon";

revoke update on table "public"."topup_requests" from "anon";

revoke delete on table "public"."topup_requests" from "authenticated";

revoke insert on table "public"."topup_requests" from "authenticated";

revoke references on table "public"."topup_requests" from "authenticated";

revoke select on table "public"."topup_requests" from "authenticated";

revoke trigger on table "public"."topup_requests" from "authenticated";

revoke truncate on table "public"."topup_requests" from "authenticated";

revoke update on table "public"."topup_requests" from "authenticated";

revoke delete on table "public"."topup_requests" from "service_role";

revoke insert on table "public"."topup_requests" from "service_role";

revoke references on table "public"."topup_requests" from "service_role";

revoke select on table "public"."topup_requests" from "service_role";

revoke trigger on table "public"."topup_requests" from "service_role";

revoke truncate on table "public"."topup_requests" from "service_role";

revoke update on table "public"."topup_requests" from "service_role";

revoke delete on table "public"."transactions" from "anon";

revoke insert on table "public"."transactions" from "anon";

revoke references on table "public"."transactions" from "anon";

revoke select on table "public"."transactions" from "anon";

revoke trigger on table "public"."transactions" from "anon";

revoke truncate on table "public"."transactions" from "anon";

revoke update on table "public"."transactions" from "anon";

revoke delete on table "public"."transactions" from "authenticated";

revoke insert on table "public"."transactions" from "authenticated";

revoke references on table "public"."transactions" from "authenticated";

revoke select on table "public"."transactions" from "authenticated";

revoke trigger on table "public"."transactions" from "authenticated";

revoke truncate on table "public"."transactions" from "authenticated";

revoke update on table "public"."transactions" from "authenticated";

revoke delete on table "public"."transactions" from "service_role";

revoke insert on table "public"."transactions" from "service_role";

revoke references on table "public"."transactions" from "service_role";

revoke select on table "public"."transactions" from "service_role";

revoke trigger on table "public"."transactions" from "service_role";

revoke truncate on table "public"."transactions" from "service_role";

revoke update on table "public"."transactions" from "service_role";

revoke delete on table "public"."unmatched_transfers" from "anon";

revoke insert on table "public"."unmatched_transfers" from "anon";

revoke references on table "public"."unmatched_transfers" from "anon";

revoke select on table "public"."unmatched_transfers" from "anon";

revoke trigger on table "public"."unmatched_transfers" from "anon";

revoke truncate on table "public"."unmatched_transfers" from "anon";

revoke update on table "public"."unmatched_transfers" from "anon";

revoke delete on table "public"."unmatched_transfers" from "authenticated";

revoke insert on table "public"."unmatched_transfers" from "authenticated";

revoke references on table "public"."unmatched_transfers" from "authenticated";

revoke select on table "public"."unmatched_transfers" from "authenticated";

revoke trigger on table "public"."unmatched_transfers" from "authenticated";

revoke truncate on table "public"."unmatched_transfers" from "authenticated";

revoke update on table "public"."unmatched_transfers" from "authenticated";

revoke delete on table "public"."unmatched_transfers" from "service_role";

revoke insert on table "public"."unmatched_transfers" from "service_role";

revoke references on table "public"."unmatched_transfers" from "service_role";

revoke select on table "public"."unmatched_transfers" from "service_role";

revoke trigger on table "public"."unmatched_transfers" from "service_role";

revoke truncate on table "public"."unmatched_transfers" from "service_role";

revoke update on table "public"."unmatched_transfers" from "service_role";

revoke delete on table "public"."wallets" from "anon";

revoke insert on table "public"."wallets" from "anon";

revoke references on table "public"."wallets" from "anon";

revoke select on table "public"."wallets" from "anon";

revoke trigger on table "public"."wallets" from "anon";

revoke truncate on table "public"."wallets" from "anon";

revoke update on table "public"."wallets" from "anon";

revoke delete on table "public"."wallets" from "authenticated";

revoke insert on table "public"."wallets" from "authenticated";

revoke references on table "public"."wallets" from "authenticated";

revoke select on table "public"."wallets" from "authenticated";

revoke trigger on table "public"."wallets" from "authenticated";

revoke truncate on table "public"."wallets" from "authenticated";

revoke update on table "public"."wallets" from "authenticated";

revoke delete on table "public"."wallets" from "service_role";

revoke insert on table "public"."wallets" from "service_role";

revoke references on table "public"."wallets" from "service_role";

revoke select on table "public"."wallets" from "service_role";

revoke trigger on table "public"."wallets" from "service_role";

revoke truncate on table "public"."wallets" from "service_role";

revoke update on table "public"."wallets" from "service_role";

alter table "public"."subscriptions" alter column "subscription_id" set default extensions.uuid_generate_v4();

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.calculate_data_retention_period(plan_id text)
 RETURNS interval
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN CASE 
        WHEN plan_id = 'starter' THEN INTERVAL '7 days'
        WHEN plan_id = 'growth' THEN INTERVAL '30 days'
        WHEN plan_id = 'scale' THEN INTERVAL '90 days'
        WHEN plan_id = 'enterprise' THEN INTERVAL '180 days'
        ELSE INTERVAL '7 days' -- Default fallback
    END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_add_domain_to_bm(p_bm_asset_id uuid, p_organization_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    current_count INTEGER;
    limit_per_bm INTEGER;
BEGIN
    -- Get current domain count for this BM
    SELECT get_bm_domain_count(p_bm_asset_id) INTO current_count;
    
    -- Get the limit per BM for this organization's plan
    SELECT get_domains_per_bm_limit(p_organization_id) INTO limit_per_bm;
    
    -- -1 means unlimited
    IF limit_per_bm = -1 THEN
        RETURN TRUE;
    END IF;
    
    -- Check if under limit
    RETURN current_count < limit_per_bm;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_organization_membership(p_user_id uuid, p_organization_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  -- Use SECURITY DEFINER to bypass RLS when checking membership
  SELECT EXISTS (
    SELECT 1 FROM public.organization_members 
    WHERE user_id = p_user_id AND organization_id = p_organization_id
  );
$function$
;

CREATE OR REPLACE FUNCTION public.check_pixel_request_exists(p_organization_id uuid, p_pixel_id text, p_business_manager_id text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_count INTEGER;
BEGIN
    -- Check for existing pending/processing requests for same pixel+BM combination
    SELECT COUNT(*)
    INTO v_count
    FROM public.pixel_requests
    WHERE organization_id = p_organization_id
        AND pixel_id = p_pixel_id
        AND business_manager_id = p_business_manager_id
        AND status IN ('pending', 'processing');
    
    RETURN v_count > 0;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_expired_organizations()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_deleted_count INTEGER := 0;
    v_org_record RECORD;
BEGIN
    -- Find organizations past their retention period
    FOR v_org_record IN
        SELECT organization_id, name
        FROM public.organizations
        WHERE subscription_status = 'grace_period'
          AND data_retention_until < NOW()
    LOOP
        -- Archive historical data (transactions, tickets, etc.)
        -- This is a soft delete - we keep the org but mark it as deleted
        UPDATE public.organizations
        SET 
            subscription_status = 'deleted',
            name = 'DELETED_' || v_org_record.organization_id::TEXT,
            updated_at = NOW()
        WHERE organization_id = v_org_record.organization_id;
        
        -- Permanently deactivate all assets
        UPDATE public.asset_binding
        SET is_active = FALSE, updated_at = NOW()
        WHERE organization_id = v_org_record.organization_id;
        
        v_deleted_count := v_deleted_count + 1;
    END LOOP;
    
    RETURN v_deleted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.complete_topup_transfer(p_organization_id uuid, p_amount_cents integer, p_request_id uuid DEFAULT NULL::uuid)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_wallet_id UUID;
    v_account_name TEXT;
    v_account_id TEXT;
    v_current_balance INTEGER;
    v_current_reserved INTEGER;
BEGIN
    -- Get wallet for organization
    SELECT wallet_id, balance_cents, reserved_balance_cents 
    INTO v_wallet_id, v_current_balance, v_current_reserved
    FROM public.wallets
    WHERE organization_id = p_organization_id;
    
    IF v_wallet_id IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Get account info from topup request using semantic ID 'request_id'
    IF p_request_id IS NOT NULL THEN
        SELECT ad_account_name, ad_account_id
        INTO v_account_name, v_account_id
        FROM public.topup_requests 
        WHERE request_id = p_request_id;
    END IF;
    
    -- Set defaults if extraction failed
    v_account_name := COALESCE(v_account_name, 'Ad Account');
    v_account_id := COALESCE(v_account_id, 'Unknown');

    -- CORRECT LOGIC: When admin completes a topup request:
    -- 1. Deduct the money from actual balance (money leaves wallet)
    -- 2. Release the reserved funds (unreserve the amount)
    UPDATE public.wallets
    SET 
        balance_cents = balance_cents - p_amount_cents,  -- Deduct from actual balance
        reserved_balance_cents = GREATEST(0, reserved_balance_cents - p_amount_cents),  -- Release reserved
        updated_at = NOW()
    WHERE wallet_id = v_wallet_id;
    
    -- Verify the wallet has enough balance (this should always pass since funds were reserved)
    IF v_current_balance < p_amount_cents THEN
        RAISE EXCEPTION 'Insufficient wallet balance. Balance: %, Required: %', v_current_balance, p_amount_cents;
    END IF;
    
    -- Create transaction record for the topup (negative = money leaving wallet)
    -- FIXED: Added missing VALUES keyword
    INSERT INTO public.transactions (
        organization_id,
        wallet_id,
        type,
        amount_cents,
        status,
        description,
        metadata
    ) VALUES (
        p_organization_id,
        v_wallet_id,
        'topup',
        -p_amount_cents, -- Negative because money is leaving the wallet
        'completed',
        'Ad Account Top-up - ' || v_account_name,
        jsonb_build_object(
            'ad_account_id', v_account_id,
            'ad_account_name', v_account_name,
            'topup_request_id', p_request_id
        )
    );
    
    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fulfill_pixel_connection_request(p_application_id uuid, p_admin_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_app_record RECORD;
    v_asset_id UUID;
BEGIN
    -- Get application details
    SELECT * INTO v_app_record
    FROM public.application
    WHERE application_id = p_application_id
      AND request_type = 'pixel_connection'
      AND status = 'processing';
    
    IF v_app_record IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Create or update pixel asset
    INSERT INTO public.asset (
        type,
        dolphin_id,
        name,
        status,
        metadata,
        created_at,
        updated_at
    ) VALUES (
        'pixel',
        v_app_record.pixel_id,
        v_app_record.pixel_name,
        'active',
        jsonb_build_object(
            'business_manager_id', v_app_record.target_bm_dolphin_id,
            'connected_at', NOW()
        ),
        NOW(),
        NOW()
    ) 
    ON CONFLICT (type, dolphin_id) 
    DO UPDATE SET 
        name = EXCLUDED.name,
        status = EXCLUDED.status,
        metadata = EXCLUDED.metadata,
        updated_at = NOW()
    RETURNING asset_id INTO v_asset_id;
    
    -- Create asset binding
    INSERT INTO public.asset_binding (
        asset_id,
        organization_id,
        status,
        is_active,
        bound_by,
        bound_at,
        created_at,
        updated_at
    ) VALUES (
        v_asset_id,
        v_app_record.organization_id,
        'active',
        TRUE,
        p_admin_user_id,
        NOW(),
        NOW(),
        NOW()
    ) ON CONFLICT (asset_id, organization_id) 
    DO UPDATE SET 
        status = EXCLUDED.status,
        is_active = EXCLUDED.is_active,
        updated_at = NOW();
    
    -- Create fulfillment record
    INSERT INTO public.application_fulfillment (
        application_id,
        asset_id,
        created_at
    ) VALUES (
        p_application_id,
        v_asset_id,
        NOW()
    ) ON CONFLICT (application_id, asset_id) DO NOTHING;
    
    -- Mark application as fulfilled
    UPDATE public.application
    SET 
        status = 'fulfilled',
        fulfilled_by = p_admin_user_id,
        fulfilled_at = NOW(),
        updated_at = NOW()
    WHERE application_id = p_application_id;
    
    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_assets_for_deactivation(p_organization_id uuid, p_asset_type text, p_count_to_deactivate integer)
 RETURNS TABLE(asset_id uuid, name text, last_topup_date timestamp with time zone, total_topup_amount_cents bigint, last_activity_date timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        a.asset_id,
        a.name,
        ab.last_topup_date,
        ab.total_topup_amount_cents,
        ab.last_activity_date
    FROM public.asset_binding ab
    JOIN public.asset a ON ab.asset_id = a.asset_id
    WHERE ab.organization_id = p_organization_id
      AND a.type = p_asset_type
      AND ab.is_active = TRUE
    ORDER BY 
        ab.last_topup_date ASC NULLS FIRST,
        ab.total_topup_amount_cents ASC,
        ab.last_activity_date ASC
    LIMIT p_count_to_deactivate;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_bm_domain_count(p_bm_asset_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN (
        SELECT COUNT(*)
        FROM public.bm_domains
        WHERE bm_asset_id = p_bm_asset_id
        AND is_active = true
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_domains_per_bm_limit(p_organization_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    org_record RECORD;
    plan_limit INTEGER;
BEGIN
    -- Get organization data
    SELECT * INTO org_record
    FROM public.organizations
    WHERE organization_id = p_organization_id;
    
    IF org_record IS NULL THEN
        RETURN 0;
    END IF;
    
    -- Get limit from pricing config based on plan
    -- These limits match the pricing config
    CASE org_record.plan_id
        WHEN 'starter' THEN plan_limit := 2;
        WHEN 'growth' THEN plan_limit := 3;
        WHEN 'scale' THEN plan_limit := 5;
        WHEN 'enterprise' THEN plan_limit := -1; -- Unlimited
        ELSE plan_limit := 0; -- Free plan
    END CASE;
    
    RETURN plan_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_organization_assets(p_organization_id uuid, p_asset_type text DEFAULT NULL::text)
 RETURNS TABLE(asset_id uuid, type text, dolphin_id text, name text, status text, metadata jsonb, bound_at timestamp with time zone, binding_id uuid, last_synced_at timestamp with time zone, is_active boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Simplified version - service role bypasses RLS anyway
    RETURN QUERY
    SELECT
        a.asset_id,
        a.type,
        a.dolphin_id,
        a.name,
        a.status,
        a.metadata,
        ab.bound_at,
        ab.binding_id,
        a.last_synced_at,
        ab.is_active
    FROM
        public.asset_binding ab
    JOIN
        public.asset a ON ab.asset_id = a.asset_id
    WHERE
        ab.organization_id = p_organization_id
        AND ab.status = 'active'
        AND (p_asset_type IS NULL OR a.type = p_asset_type)
    ORDER BY
        ab.bound_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_organization_dashboard_data(org_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'organization', json_build_object(
            'organization_id', o.organization_id,
            'name', o.name,
            'balance_cents', COALESCE(w.balance_cents, 0),
            'balance', COALESCE(w.balance_cents, 0) / 100.0,
            'reserved_balance_cents', COALESCE(w.reserved_balance_cents, 0),
            'subscription_status', o.subscription_status,
            'created_at', o.created_at
        ),
        'summary', json_build_object(
            'pending_applications', COALESCE(ds.pending_applications, 0),
            'open_tickets', COALESCE(ds.open_tickets, 0)
        ),
        'wallets', COALESCE(
            (SELECT json_agg(json_build_object(
                'wallet_id', w.wallet_id,
                'balance_cents', w.balance_cents,
                'balance', w.balance_cents / 100.0
            )) FROM wallets w WHERE w.organization_id = org_id),
            '[]'::json
        )
    ) INTO result
    FROM organizations o
    LEFT JOIN wallets w ON o.organization_id = w.organization_id
    LEFT JOIN dashboard_summary ds ON o.organization_id = ds.organization_id
    WHERE o.organization_id = org_id;
    
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_organization_pixels(p_organization_id uuid)
 RETURNS TABLE(id uuid, type text, pixel_id text, pixel_name text, business_manager_id text, business_manager_name text, status text, is_active boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    -- Get active pixel assets
    SELECT 
        a.asset_id as id,
        'asset'::TEXT as type,
        a.dolphin_id as pixel_id,
        a.name as pixel_name,
        a.metadata->>'business_manager_id' as business_manager_id,
        a.metadata->>'business_manager_name' as business_manager_name,
        a.status,
        ab.is_active,
        a.created_at,
        a.updated_at
    FROM public.asset a
    JOIN public.asset_binding ab ON a.asset_id = ab.asset_id
    WHERE ab.organization_id = p_organization_id
      AND a.type = 'pixel'
      AND ab.status = 'active'
    
    UNION ALL
    
    -- Get pending pixel applications
    SELECT 
        app.application_id as id,
        'application'::TEXT as type,
        app.pixel_id,
        app.pixel_name,
        app.target_bm_dolphin_id as business_manager_id,
        NULL::TEXT as business_manager_name, -- Will be populated from BM data
        app.status,
        NULL::BOOLEAN as is_active,
        app.created_at,
        app.updated_at
    FROM public.application app
    WHERE app.organization_id = p_organization_id
      AND app.request_type = 'pixel_connection'
      AND app.status IN ('pending', 'processing')
    
    ORDER BY created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_promotion_url_limit(org_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    org_record RECORD;
    plan_record RECORD;
BEGIN
    -- Get organization data
    SELECT * INTO org_record
    FROM organizations
    WHERE organization_id = org_id;
    
    IF org_record IS NULL THEN
        RETURN 0;
    END IF;
    
    -- Get plan data
    SELECT * INTO plan_record
    FROM plans
    WHERE plan_id = org_record.plan_id;
    
    IF plan_record IS NULL THEN
        RETURN 0; -- Free plan default
    END IF;
    
    RETURN COALESCE(plan_record.max_promotion_urls, 0);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_tickets_with_metadata(org_id uuid DEFAULT NULL::uuid)
 RETURNS TABLE(ticket_id uuid, organization_id uuid, created_by uuid, assigned_to uuid, subject text, category text, status text, affected_asset_ids text[], affected_assets jsonb, tags text[], created_at timestamp with time zone, updated_at timestamp with time zone, ticket_number integer, message_count bigint, last_message_at timestamp with time zone, last_message_content text, last_message_sender uuid, unread_messages bigint, creator_name text, creator_email text, assignee_name text, assignee_email text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        t.ticket_id,
        t.organization_id,
        t.created_by,
        t.assigned_to,
        t.subject,
        t.category,
        t.status,
        t.affected_asset_ids,
        public.resolve_asset_names(t.affected_asset_ids) as affected_assets,
        t.tags,
        t.created_at,
        t.updated_at,
        t.ticket_number,
        COALESCE(msg_stats.message_count, 0) as message_count,
        msg_stats.last_message_at,
        msg_stats.last_message_content,
        msg_stats.last_message_sender,
        COALESCE(msg_stats.unread_messages, 0) as unread_messages,
        creator.name as creator_name,
        creator.email as creator_email,
        assignee.name as assignee_name,
        assignee.email as assignee_email
    FROM public.support_tickets t
    LEFT JOIN public.profiles creator ON t.created_by = creator.profile_id
    LEFT JOIN public.profiles assignee ON t.assigned_to = assignee.profile_id
    LEFT JOIN (
        SELECT 
            m.ticket_id,
            COUNT(*) as message_count,
            MAX(m.created_at) as last_message_at,
            (SELECT content FROM public.support_ticket_messages sm1 WHERE sm1.ticket_id = m.ticket_id ORDER BY sm1.created_at DESC LIMIT 1) as last_message_content,
            (SELECT sender_id FROM public.support_ticket_messages sm2 WHERE sm2.ticket_id = m.ticket_id ORDER BY sm2.created_at DESC LIMIT 1) as last_message_sender,
            COUNT(CASE WHEN NOT m.read_by_customer AND m.sender_id != t.created_by THEN 1 END) as unread_messages
        FROM public.support_ticket_messages m
        JOIN public.support_tickets t ON m.ticket_id = t.ticket_id
        WHERE NOT m.is_internal
        GROUP BY m.ticket_id
    ) msg_stats ON t.ticket_id = msg_stats.ticket_id
    WHERE (org_id IS NULL OR t.organization_id = org_id)
    ORDER BY t.updated_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_organizations(p_user_id uuid)
 RETURNS TABLE(organization_id uuid)
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  -- Use SECURITY DEFINER to bypass RLS when getting user's organizations
  SELECT om.organization_id 
  FROM public.organization_members om 
  WHERE om.user_id = p_user_id
  UNION
  SELECT o.organization_id 
  FROM public.organizations o 
  WHERE o.owner_id = p_user_id;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  new_org_id UUID;
  user_email TEXT;
  user_name TEXT;
  new_org_name TEXT;
  new_wallet_id UUID;
BEGIN
  -- Get user email from auth.users
  SELECT email INTO user_email FROM auth.users WHERE id = NEW.id;
  
  -- Extract user name from metadata or email
  user_name := COALESCE(
    NEW.raw_user_meta_data->>'name',
    NEW.raw_user_meta_data->>'full_name',
    split_part(user_email, '@', 1),
    'User'
  );
  
  -- Generate organization name in the format "Name's Organization"
  new_org_name := user_name || '''s Organization';
  
  -- Create organization
  new_org_id := gen_random_uuid();
  INSERT INTO public.organizations (organization_id, name, owner_id, plan_id)
  VALUES (new_org_id, new_org_name, NEW.id, 'free');
  
  -- Create wallet for the organization
  new_wallet_id := gen_random_uuid();
  INSERT INTO public.wallets (wallet_id, organization_id, balance_cents, reserved_balance_cents)
  VALUES (new_wallet_id, new_org_id, 0, 0);
  
  -- Create profile
  INSERT INTO public.profiles (profile_id, email, name, avatar_url, organization_id)
  VALUES (
    NEW.id,
    user_email,
    user_name,
    NEW.raw_user_meta_data->>'avatar_url',
    new_org_id
  );
  
  -- Add user as organization member (CRITICAL: This was missing!)
  INSERT INTO public.organization_members (user_id, organization_id, role)
  VALUES (NEW.id, new_org_id, 'owner');
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_plan_downgrade(p_organization_id uuid, p_new_plan_id text, p_downgrade_date timestamp with time zone DEFAULT now())
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_current_plan TEXT;
    v_current_bm_count INTEGER;
    v_current_account_count INTEGER;
    v_new_bm_limit INTEGER;
    v_new_account_limit INTEGER;
    v_bm_to_deactivate INTEGER;
    v_accounts_to_deactivate INTEGER;
    v_asset_record RECORD;
BEGIN
    -- Get current plan and counts
    SELECT plan_id INTO v_current_plan
    FROM public.organizations
    WHERE organization_id = p_organization_id;
    
    -- Get current active asset counts
    SELECT 
        COUNT(CASE WHEN a.type = 'business_manager' THEN 1 END),
        COUNT(CASE WHEN a.type = 'ad_account' THEN 1 END)
    INTO v_current_bm_count, v_current_account_count
    FROM public.asset_binding ab
    JOIN public.asset a ON ab.asset_id = a.asset_id
    WHERE ab.organization_id = p_organization_id AND ab.is_active = TRUE;
    
    -- Get new plan limits
    SELECT max_businesses, max_ad_accounts
    INTO v_new_bm_limit, v_new_account_limit
    FROM public.plans
    WHERE plan_id = p_new_plan_id;
    
    -- Calculate how many assets to deactivate
    v_bm_to_deactivate := GREATEST(0, v_current_bm_count - v_new_bm_limit);
    v_accounts_to_deactivate := GREATEST(0, v_current_account_count - v_new_account_limit);
    
    -- Update organization with new plan
    UPDATE public.organizations
    SET 
        previous_plan_id = v_current_plan,
        plan_id = p_new_plan_id,
        downgrade_scheduled_at = p_downgrade_date,
        updated_at = NOW()
    WHERE organization_id = p_organization_id;
    
    -- Deactivate excess business managers
    IF v_bm_to_deactivate > 0 THEN
        FOR v_asset_record IN
            SELECT asset_id FROM public.get_assets_for_deactivation(
                p_organization_id, 'business_manager', v_bm_to_deactivate
            )
        LOOP
            UPDATE public.asset_binding
            SET is_active = FALSE, updated_at = NOW()
            WHERE asset_id = v_asset_record.asset_id;
        END LOOP;
    END IF;
    
    -- Deactivate excess ad accounts
    IF v_accounts_to_deactivate > 0 THEN
        FOR v_asset_record IN
            SELECT asset_id FROM public.get_assets_for_deactivation(
                p_organization_id, 'ad_account', v_accounts_to_deactivate
            )
        LOOP
            UPDATE public.asset_binding
            SET is_active = FALSE, updated_at = NOW()
            WHERE asset_id = v_asset_record.asset_id;
        END LOOP;
    END IF;
    
    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_subscription_cancellation(p_organization_id uuid, p_cancelled_at timestamp with time zone DEFAULT now())
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_current_plan TEXT;
    v_retention_period INTERVAL;
BEGIN
    -- Get current plan
    SELECT plan_id INTO v_current_plan
    FROM public.organizations
    WHERE organization_id = p_organization_id;
    
    -- Calculate retention period
    v_retention_period := public.calculate_data_retention_period(v_current_plan);
    
    -- Update organization status
    UPDATE public.organizations
    SET 
        subscription_status = 'grace_period',
        subscription_cancelled_at = p_cancelled_at,
        data_retention_until = p_cancelled_at + v_retention_period,
        updated_at = NOW()
    WHERE organization_id = p_organization_id;
    
    -- Deactivate all assets immediately
    UPDATE public.asset_binding
    SET 
        is_active = FALSE,
        updated_at = NOW()
    WHERE organization_id = p_organization_id;
    
    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_topup_request_changes()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- On INSERT (new topup request)
    IF TG_OP = 'INSERT' THEN
        -- Reserve funds using total_deducted_cents (which includes fees)
        IF NOT public.reserve_funds_for_topup(NEW.organization_id, NEW.total_deducted_cents) THEN
            RAISE EXCEPTION 'Insufficient available balance for topup request. Required: %', NEW.total_deducted_cents;
        END IF;
        
        RETURN NEW;
    END IF;
    
    -- On UPDATE (status change)
    IF TG_OP = 'UPDATE' THEN
        -- If request was cancelled, rejected, or failed, release reserved funds
        IF OLD.status = 'pending' AND NEW.status IN ('rejected', 'cancelled', 'failed') THEN
            PERFORM public.release_reserved_funds(NEW.organization_id, OLD.total_deducted_cents);
        END IF;
        
        -- If request was completed, complete the transfer and create transaction
        -- Always use total_deducted_cents (includes fees) and pass the semantic request_id
        IF OLD.status IN ('pending', 'processing') AND NEW.status = 'completed' THEN
            PERFORM public.complete_topup_transfer(NEW.organization_id, NEW.total_deducted_cents, NEW.request_id);
        END IF;
        
        RETURN NEW;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_admin(user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  -- Use SECURITY DEFINER to bypass RLS when checking admin status
  SELECT COALESCE(
    (SELECT is_superuser FROM public.profiles WHERE profile_id = user_id LIMIT 1),
    false
  );
$function$
;

CREATE OR REPLACE FUNCTION public.migrate_promotion_urls_to_bm_domains()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    promo_record RECORD;
    first_bm_id UUID;
BEGIN
    -- For each organization's promotion URLs, assign them to their first BM
    FOR promo_record IN 
        SELECT DISTINCT organization_id 
        FROM public.promotion_urls 
        WHERE is_active = true
    LOOP
        -- Get the first BM for this organization
        SELECT a.asset_id INTO first_bm_id
        FROM public.asset a
        JOIN public.asset_binding ab ON a.asset_id = ab.asset_id
        WHERE ab.organization_id = promo_record.organization_id
        AND a.type = 'business_manager'
        AND ab.status = 'active'
        AND ab.is_active = true
        ORDER BY ab.bound_at
        LIMIT 1;
        
        -- If organization has a BM, migrate their URLs
        IF first_bm_id IS NOT NULL THEN
            INSERT INTO public.bm_domains (organization_id, bm_asset_id, domain_url, is_active)
            SELECT 
                organization_id,
                first_bm_id,
                url,
                is_active
            FROM public.promotion_urls
            WHERE organization_id = promo_record.organization_id
            AND is_active = true
            ON CONFLICT (bm_asset_id, domain_url) DO NOTHING;
        END IF;
    END LOOP;
    
    RAISE NOTICE 'Migration completed: promotion_urls -> bm_domains';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.release_reserved_funds(org_id uuid, amount_cents integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    UPDATE public.wallets
    SET reserved_balance_cents = GREATEST(0, COALESCE(reserved_balance_cents, 0) - amount_cents),
        updated_at = NOW()
    WHERE organization_id = org_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reserve_funds_for_topup(org_id uuid, amount_cents integer)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    current_balance INTEGER;
    current_reserved INTEGER;
    available_balance INTEGER;
BEGIN
    -- Get current balances
    SELECT balance_cents, COALESCE(reserved_balance_cents, 0)
    INTO current_balance, current_reserved
    FROM public.wallets
    WHERE organization_id = org_id;
    
    IF current_balance IS NULL THEN
        RETURN FALSE;
    END IF;
    
    available_balance := current_balance - current_reserved;
    
    -- Check if sufficient funds available
    IF available_balance < amount_cents THEN
        RETURN FALSE;
    END IF;
    
    -- Reserve the funds
    UPDATE public.wallets
    SET reserved_balance_cents = current_reserved + amount_cents,
        updated_at = NOW()
    WHERE organization_id = org_id;
    
    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.resolve_asset_names(asset_ids text[])
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    result JSONB := '[]'::JSONB;
    asset_id_param TEXT;
    asset_record RECORD;
BEGIN
    -- Return empty array if no asset IDs provided
    IF asset_ids IS NULL OR array_length(asset_ids, 1) IS NULL THEN
        RETURN result;
    END IF;
    
    -- Loop through each asset ID and resolve its name
    FOREACH asset_id_param IN ARRAY asset_ids
    LOOP
        -- Try to find the asset in the asset table with proper table alias
        SELECT a.asset_id, a.name, a.type, a.dolphin_id
        INTO asset_record
        FROM public.asset a
        WHERE a.asset_id::TEXT = asset_id_param OR a.dolphin_id = asset_id_param;
        
        -- If found, add to result
        IF FOUND THEN
            result := result || jsonb_build_object(
                'id', asset_record.asset_id,
                'name', asset_record.name,
                'type', asset_record.type,
                'dolphin_id', asset_record.dolphin_id
            );
        ELSE
            -- If not found, add placeholder
            result := result || jsonb_build_object(
                'id', asset_id_param,
                'name', 'Unknown Asset',
                'type', 'unknown',
                'dolphin_id', asset_id_param
            );
        END IF;
    END LOOP;
    
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.submit_pixel_connection_request(p_organization_id uuid, p_pixel_id text, p_pixel_name text, p_business_manager_id text, p_requested_by uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_application_id UUID;
BEGIN
    -- Create application record
    INSERT INTO public.application (
        organization_id,
        request_type,
        pixel_id,
        pixel_name,
        target_bm_dolphin_id,
        status,
        created_at,
        updated_at
    ) VALUES (
        p_organization_id,
        'pixel_connection',
        p_pixel_id,
        p_pixel_name,
        p_business_manager_id,
        'pending',
        NOW(),
        NOW()
    ) RETURNING application_id INTO v_application_id;
    
    RETURN v_application_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.toggle_asset_activation(p_asset_id uuid, p_organization_id uuid, p_is_active boolean)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    binding_exists BOOLEAN;
BEGIN
    -- Check if the binding exists and belongs to the organization
    SELECT EXISTS(
        SELECT 1 FROM asset_binding 
        WHERE asset_id = p_asset_id 
        AND organization_id = p_organization_id 
        AND status = 'active'
    ) INTO binding_exists;
    
    IF NOT binding_exists THEN
        RETURN FALSE;
    END IF;
    
    -- Update the activation status
    UPDATE asset_binding 
    SET is_active = p_is_active,
        updated_at = NOW()
    WHERE asset_id = p_asset_id 
    AND organization_id = p_organization_id 
    AND status = 'active';
    
    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.toggle_asset_activation_cascade(p_asset_id uuid, p_organization_id uuid, p_is_active boolean)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    binding_exists BOOLEAN;
    asset_type TEXT;
    bm_dolphin_id TEXT;
BEGIN
    -- Check if the binding exists and belongs to the organization
    SELECT EXISTS(
        SELECT 1 FROM asset_binding ab
        JOIN asset a ON ab.asset_id = a.asset_id
        WHERE ab.asset_id = p_asset_id 
        AND ab.organization_id = p_organization_id 
        AND ab.status = 'active'
    ) INTO binding_exists;
    
    IF NOT binding_exists THEN
        RETURN FALSE;
    END IF;
    
    -- Get the asset type and dolphin_id
    SELECT a.type, a.dolphin_id INTO asset_type, bm_dolphin_id
    FROM asset a
    JOIN asset_binding ab ON a.asset_id = ab.asset_id
    WHERE ab.asset_id = p_asset_id 
    AND ab.organization_id = p_organization_id 
    AND ab.status = 'active';
    
    -- Update the activation status of the main asset
    UPDATE asset_binding 
    SET is_active = p_is_active,
        updated_at = NOW()
    WHERE asset_id = p_asset_id 
    AND organization_id = p_organization_id 
    AND status = 'active';
    
    -- If this is a business manager being deactivated, also deactivate all its ad accounts
    IF asset_type = 'business_manager' AND p_is_active = FALSE THEN
        UPDATE asset_binding 
        SET is_active = FALSE,
            updated_at = NOW()
        WHERE organization_id = p_organization_id 
        AND status = 'active'
        AND asset_id IN (
            SELECT a.asset_id 
            FROM asset a
            WHERE a.type = 'ad_account'
            AND a.metadata->>'business_manager_id' = bm_dolphin_id
        );
    END IF;
    
    -- If this is a business manager being activated, we DON'T automatically activate ad accounts
    -- This gives users more control - they can choose which ad accounts to reactivate
    
    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_binance_pay_orders_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_pixel_request_status(p_request_id uuid, p_status text, p_admin_notes text DEFAULT NULL::text, p_processed_by uuid DEFAULT NULL::uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_updated_rows INTEGER;
BEGIN
    -- Validate status
    IF p_status NOT IN ('pending', 'processing', 'completed', 'rejected') THEN
        RAISE EXCEPTION 'Invalid status: %', p_status;
    END IF;

    -- Update the request
    UPDATE public.pixel_requests 
    SET 
        status = p_status,
        admin_notes = COALESCE(p_admin_notes, admin_notes),
        processed_by = COALESCE(p_processed_by, processed_by),
        processed_at = CASE 
            WHEN p_status IN ('completed', 'rejected') THEN NOW()
            ELSE processed_at
        END,
        updated_at = NOW()
    WHERE request_id = p_request_id;

    GET DIAGNOSTICS v_updated_rows = ROW_COUNT;
    
    RETURN v_updated_rows > 0;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_ticket_timestamp_on_message()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Update the parent ticket's updated_at field when a message is inserted
    UPDATE public.support_tickets 
    SET updated_at = NOW()
    WHERE ticket_id = NEW.ticket_id;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_bm_asset_type()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Check if the referenced asset is actually a business manager
    IF NOT EXISTS (
        SELECT 1 FROM public.asset 
        WHERE asset_id = NEW.bm_asset_id 
        AND type = 'business_manager'
    ) THEN
        RAISE EXCEPTION 'Referenced asset must be a business manager';
    END IF;
    
    RETURN NEW;
END;
$function$
;


